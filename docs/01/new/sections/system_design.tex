\section{System Design}

DecisionDB is implemented as a Python package backed by SQLite. It manages five entity types through a relational schema with content-addressed primary keys and foreign-key constraints.

\subsection{Content Addressing}

All identifiers are computed deterministically from content. Given an entity's payload as a Python dictionary, DecisionDB serializes it to canonical JSON with keys sorted alphabetically, no whitespace, arrays in declaration order, floats as strings, and explicit version fields. It then computes the SHA-256 digest of the UTF-8 encoding, truncates to the first 16 hexadecimal characters, and prepends a type-specific prefix. Identical content always produces identical identifiers, regardless of when or where the computation occurs.

\subsection{Schema}

The relational schema contains five core tables whose relationships and roles are shown in Figure~\ref{fig:schema}. Each table enforces content-addressed primary keys and foreign-key constraints that link the full provenance chain from snapshot through representation and engine execution to decision identity. All writes are append-only, scoped by experiment identifier, and executed within transactions. Inserts use an insert-or-ignore strategy for idempotency, so re-inserting the same content-addressed entity is a no-op. Each table stores additional metadata such as artifact manifests, URIs, hashes, and configuration records; only the structural fields are shown in the diagram.

\begin{figure}[t]
  \centering
  \begin{tikzpicture}[
    node distance=8mm and 12mm,
    entity/.style={draw, rounded corners, align=left, inner sep=6pt, text width=32mm, font=\avenirultralight\footnotesize, fill=blue!6},
    fk/.style={-Latex, thick, black!50},
    fklbl/.style={font=\avenirultralight\scriptsize, text=black!40, fill=white, inner sep=1pt}
  ]

  % Top row: main chain
  \node[entity] (snap) {%
    snapshots\\[1pt]
    {\scriptsize\color{black!50} snap\_id \textnormal{(PK)}}};

  \node[entity, right=of snap] (repr) {%
    representations\\[1pt]
    {\scriptsize\color{black!50} repr\_id \textnormal{(PK)}}\\
    {\scriptsize\color{black!50} snapshot\_id \textnormal{(FK)}}};

  \node[entity, right=of repr] (runs) {%
    engine\_runs\\[1pt]
    {\scriptsize\color{black!50} run\_id \textnormal{(PK)}}\\
    {\scriptsize\color{black!50} repr\_id \textnormal{(FK)}}};

  % Bottom row: f_map and decisions
  \node[entity, below=12mm of $(repr.south)!0.5!(runs.south)$] (fmap) {%
    f\_map\\[1pt]
    {\scriptsize\color{black!50} repr\_id, run\_id \textnormal{(PK)}}\\
    {\scriptsize\color{black!50} dec\_id \textnormal{(FK)}}};

  \node[entity, right=of fmap] (dec) {%
    decisions\\[1pt]
    {\scriptsize\color{black!50} dec\_id \textnormal{(PK)}}\\
    {\scriptsize\color{black!50} policy\_id}};

  % FK arrows
  \draw[fk] (repr.west) -- node[fklbl, above] {FK} (snap.east);
  \draw[fk] (runs.west) -- node[fklbl, above] {FK} (repr.east);
  \draw[fk] (fmap.north) -- ++(0,0.35) -| node[fklbl, near start, above] {FK} (repr.south);
  \draw[fk] (fmap.north east) -- ++(0.15,0.35) -| node[fklbl, near start, above] {FK} (runs.south);
  \draw[fk] (fmap.east) -- node[fklbl, above] {FK} (dec.west);

  \end{tikzpicture}

  \bigskip

  \tablestyle
  \rowcolors{2}{tableShade}{white}
  \begin{tabular}{@{\hskip 8pt}l l R{68mm}@{\hskip 8pt}}
  \toprule
  \rowcolor{white}
  Table & Primary key & Role \\
  \midrule
  snapshots & snap\_* & Immutable frozen input state and its artifact manifest \\
  representations & repr\_* & Deterministic encodings of snapshots under a declared parameterization \\
  engine\_runs & run\_* & Execution records of the fixed engine on specific representations \\
  decisions & dec\_* & Discrete decision identities extracted by an equivalence policy \\
  f\_map & composite & Materialized decision-valued map linking repr\_*, run\_*, and dec\_* \\
  \bottomrule
  \end{tabular}

  \caption{DecisionDB relational schema and entity roles.}
  \label{fig:schema}
\end{figure}

\subsection{Equivalence Policies}

An equivalence policy defines how raw engine output is reduced to a decision identity. Each policy specifies a hash source, identifying which field of the raw output carries decision-relevant content such as the route node sequence. It also specifies a canonicalization rule that determines how to serialize the extracted content, and a match rule that determines identity such as SHA-256 equality. The policy itself is content-addressed, so any change to the policy definition produces a new policy identifier and new decision identifiers downstream.

\subsection{Replay Verification}

Replay verification takes a persisted decision record, reloads the stored raw output and policy specification, recomputes the policy identifier, payload hash, and decision identifier, and checks them against the persisted values. Because replay is read-only and writes no rows, a successful pass confirms that the content-addressing chain from raw output through policy application to decision identity is deterministic and self-consistent.
