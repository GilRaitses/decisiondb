\section{System Design}

DecisionDB is implemented as a Python package backed by SQLite. It manages five entity types through a relational schema with content-addressed primary keys and foreign-key constraints.

\subsection{Content Addressing}

All identifiers are computed deterministically from content. Given an entity's payload as a Python dictionary, DecisionDB serializes it to canonical JSON with keys sorted alphabetically, no whitespace, arrays in declaration order, floats as strings, and explicit version fields. It then computes the SHA-256 digest of the UTF-8 encoding, truncates to the first 16 hexadecimal characters, and prepends a type-specific prefix. Identical content always produces identical identifiers, regardless of when or where the computation occurs.

\subsection{Schema}

The relational schema contains five core tables. Figure~\ref{fig:schema} shows their foreign-key relationships and Table~\ref{tab:schema} summarizes each table's role. Each table enforces content-addressed primary keys and foreign-key constraints that link the full provenance chain from snapshot through representation and engine execution to decision identity. All writes are append-only, scoped by experiment identifier, and executed within transactions. Inserts use an insert-or-ignore strategy for idempotency, so re-inserting the same content-addressed entity is a no-op.

\begin{figure}[t]
  \centering
  \begin{tikzpicture}[
    node distance=8mm and 14mm,
    entity/.style={draw, rounded corners, align=left, inner sep=6pt, text width=32mm, font=\avenirultralight\footnotesize, fill=blue!6},
    fk/.style={-Latex, thick, black!50},
    fklbl/.style={font=\avenirultralight\scriptsize, text=black!40, fill=white, inner sep=1pt}
  ]

  \node[entity] (snap) {%
    snapshots\\[1pt]
    {\scriptsize\color{black!50} snap{\_}id (PK)}};

  \node[entity, right=of snap] (repr) {%
    representations\\[1pt]
    {\scriptsize\color{black!50} repr{\_}id (PK)}\\
    {\scriptsize\color{black!50} snapshot{\_}id (FK)}};

  \node[entity, right=of repr] (runs) {%
    engine{\_}runs\\[1pt]
    {\scriptsize\color{black!50} run{\_}id (PK)}\\
    {\scriptsize\color{black!50} repr{\_}id (FK)}};

  \node[entity, below=14mm of $(repr.south)!0.5!(runs.south)$] (fmap) {%
    f{\_}map\\[1pt]
    {\scriptsize\color{black!50} repr{\_}id, run{\_}id (PK)}\\
    {\scriptsize\color{black!50} dec{\_}id (FK)}};

  \node[entity, right=of fmap] (dec) {%
    decisions\\[1pt]
    {\scriptsize\color{black!50} dec{\_}id (PK)}\\
    {\scriptsize\color{black!50} policy{\_}id}};

  \draw[fk] (repr.west) -- node[fklbl, above] {FK} (snap.east);
  \draw[fk] (runs.west) -- node[fklbl, above] {FK} (repr.east);
  \draw[fk] (fmap.north) -- ++(0,0.4) -| node[fklbl, near start, above] {FK} (repr.south);
  \draw[fk] (fmap.north east) -- ++(0.15,0.4) -| node[fklbl, near start, above] {FK} (runs.south);
  \draw[fk] (fmap.east) -- node[fklbl, above] {FK} (dec.west);

  \end{tikzpicture}
  \caption{DecisionDB relational schema. Five tables form a content-addressed provenance chain. Foreign-key arrows indicate the direction of referential dependency, linking representations to their parent snapshot, engine runs to the representation consumed, and the decision map table to representations, runs, and decision identities.}
  \label{fig:schema}
\end{figure}

\begin{table}[t]
\centering
\caption{DecisionDB entity roles.}
\label{tab:schema}
\smallskip
\tablestyle
\rowcolors{2}{tableShade}{white}
\begin{tabular}{@{\hskip 8pt}l l R{68mm}@{\hskip 8pt}}
\toprule
\rowcolor{white}
Table & Key prefix & Role \\
\midrule
snapshots & snap & Immutable frozen input state and its artifact manifest \\
representations & repr & Deterministic encodings of snapshots under a declared parameterization \\
engine runs & run & Execution records of the fixed engine on specific representations \\
decisions & dec & Discrete decision identities extracted by an equivalence policy \\
f map & composite & Materialized decision-valued map linking representations, runs, and decisions \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Equivalence Policies}

An equivalence policy defines how raw engine output is reduced to a decision identity. Each policy specifies a hash source, identifying which field of the raw output carries decision-relevant content such as the route node sequence. It also specifies a canonicalization rule that determines how to serialize the extracted content, and a match rule that determines identity such as SHA-256 equality. The policy itself is content-addressed, so any change to the policy definition produces a new policy identifier and new decision identifiers downstream.

\subsection{Replay Verification}

Replay verification takes a persisted decision record, reloads the stored raw output and policy specification, recomputes the policy identifier, payload hash, and decision identifier, and checks them against the persisted values. Because replay is read-only and writes no rows, a successful pass confirms that the content-addressing chain from raw output through policy application to decision identity is deterministic and self-consistent.
